# æ¨¡å‹è½®è¯¢ä¸ç†”æ–­æœºåˆ¶ - æŠ€æœ¯å®ç°æ–‡æ¡£

> åˆ›å»ºæ—¥æœŸ: 2026-01-19
> ç‰ˆæœ¬: v1.0
> çŠ¶æ€: å·²å®Œæˆå®ç°

---

## ä¸€ã€åŠŸèƒ½æ¦‚è¿°

### 1.1 åŠŸèƒ½æè¿°

**æ™ºèƒ½æ¨¡å‹è½®è¯¢ (Model Polling)** æ˜¯ä¸€ä¸ªè‡ªåŠ¨æ•…éšœè½¬ç§»æœºåˆ¶ï¼Œå½“ä¸»æ¨¡å‹çš„æ‰€æœ‰è´¦å·ä¸å¯ç”¨ï¼ˆé¢åº¦è€—å°½æˆ–è¢«é™æµï¼‰æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨å°è¯•é¢„å®šä¹‰çš„å¤‡é€‰æ¨¡å‹ï¼Œç¡®ä¿æœåŠ¡æŒç»­å¯ç”¨ã€‚

### 1.2 æ ¸å¿ƒç‰¹æ€§

| ç‰¹æ€§ | æè¿° |
|------|------|
| **è‡ªåŠ¨é™çº§** | å½“ Claude/GPT æ¨¡å‹ä¸å¯ç”¨æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ° Gemini |
| **ç†”æ–­æœºåˆ¶** | å¤±è´¥çš„æ¨¡å‹è¢«ç†”æ–­ 5 åˆ†é’Ÿï¼Œé¿å…é‡å¤å°è¯• |
| **é…ç½®å¼€å…³** | å¯é€šè¿‡ UI æˆ–é…ç½®æ–‡ä»¶å¯ç”¨/ç¦ç”¨æ­¤åŠŸèƒ½ |
| **é€æ˜åˆ‡æ¢** | å“åº”å¤´ `X-Fallback-Model: true` æ ‡è¯†å·²ä½¿ç”¨å¤‡é€‰æ¨¡å‹ |

### 1.3 å¤‡é€‰æ¨¡å‹ä¼˜å…ˆçº§

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸»æ¨¡å‹å®¶æ—           â”‚ å¤‡é€‰æ¨¡å‹ä¼˜å…ˆçº§                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Claude (Opus/Sonnet) â”‚ gemini-2.5-pro â†’ gemini-2.5-flash      â”‚
â”‚ GPT (GPT-4/5/o1)     â”‚ gemini-2.5-pro â†’ gemini-2.5-flash      â”‚
â”‚ Gemini Pro           â”‚ claude-sonnet-4 â†’ gemini-2.5-flash     â”‚
â”‚ Gemini Flash         â”‚ claude-sonnet-4 â†’ gemini-2.5-pro       â”‚
â”‚ æ™ºè°± (GLM)           â”‚ gemini-2.5-pro â†’ flash â†’ claude-sonnet â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äºŒã€æ–‡ä»¶ä¿®æ”¹æ¸…å•

### 2.1 åç«¯ (Rust)

| æ–‡ä»¶ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| `src-tauri/src/proxy/config.rs` | ä¿®æ”¹ | æ·»åŠ é…ç½®é¡¹ |
| `src-tauri/src/proxy/common/model_fallback.rs` | æ–°å»º | å¤‡é€‰æ¨¡å‹æ˜ å°„é€»è¾‘ |
| `src-tauri/src/proxy/common/mod.rs` | ä¿®æ”¹ | å¯¼å‡ºæ–°æ¨¡å— |
| `src-tauri/src/proxy/token_manager.rs` | ä¿®æ”¹ | æ·»åŠ ç†”æ–­å™¨æ–¹æ³• |
| `src-tauri/src/proxy/handlers/claude.rs` | ä¿®æ”¹ | é›†æˆè½®è¯¢é€»è¾‘ |

### 2.2 å‰ç«¯ (TypeScript/React)

| æ–‡ä»¶ | æ“ä½œ | è¯´æ˜ |
|------|------|------|
| `src/types/config.ts` | ä¿®æ”¹ | æ·»åŠ ç±»å‹å®šä¹‰ |
| `src/pages/ApiProxy.tsx` | ä¿®æ”¹ | æ·»åŠ å¼€å…³ UI |
| `src/locales/zh.json` | ä¿®æ”¹ | ä¸­æ–‡ç¿»è¯‘ |
| `src/locales/en.json` | ä¿®æ”¹ | è‹±æ–‡ç¿»è¯‘ |

---

## ä¸‰ã€å®Œæ•´ä»£ç å®ç°

### 3.1 é…ç½®é¡¹å®šä¹‰

**æ–‡ä»¶ä½ç½®**: `src-tauri/src/proxy/config.rs`

**ä¿®æ”¹å†…å®¹**: åœ¨ `ExperimentalConfig` ç»“æ„ä½“ä¸­æ·»åŠ  `enable_model_polling` å­—æ®µ

```rust
/// å®éªŒæ€§é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExperimentalConfig {
    /// å¯ç”¨åŒå±‚ç­¾åç¼“å­˜ (Signature Cache)
    #[serde(default = "default_true")]
    pub enable_signature_cache: bool,
    
    /// å¯ç”¨å·¥å…·å¾ªç¯è‡ªåŠ¨æ¢å¤ (Tool Loop Recovery)
    #[serde(default = "default_true")]
    pub enable_tool_loop_recovery: bool,
    
    /// å¯ç”¨è·¨æ¨¡å‹å…¼å®¹æ€§æ£€æŸ¥ (Cross-Model Checks)
    #[serde(default = "default_true")]
    pub enable_cross_model_checks: bool,

    /// å¯ç”¨ä¸Šä¸‹æ–‡ç”¨é‡ç¼©æ”¾ (Context Usage Scaling)
    /// ç”¨äºè§£å†³å®¢æˆ·ç«¯å›  Gemini ä¸Šä¸‹æ–‡è¿‡å¤§è€Œé”™è¯¯è§¦å‘å‹ç¼©çš„é—®é¢˜
    #[serde(default = "default_true")]
    pub enable_usage_scaling: bool,

    /// å¯ç”¨æ™ºèƒ½æ¨¡å‹è½®è¯¢ (Model Polling)
    /// å½“ä¸»æ¨¡å‹æ‰€æœ‰è´¦å·ä¸å¯ç”¨æ—¶ï¼Œè‡ªåŠ¨å°è¯•å¤‡é€‰æ¨¡å‹ï¼ˆå¦‚ Gemini 3 Pro/Flashï¼‰
    /// ä½¿ç”¨ 5 åˆ†é’Ÿç†”æ–­æœºåˆ¶é¿å…é‡å¤å°è¯•å¤±è´¥çš„æ¨¡å‹
    #[serde(default)]
    pub enable_model_polling: bool,
}

impl Default for ExperimentalConfig {
    fn default() -> Self {
        Self {
            enable_signature_cache: true,
            enable_tool_loop_recovery: true,
            enable_cross_model_checks: true,
            enable_usage_scaling: true,
            enable_model_polling: false,  // é»˜è®¤å…³é—­
        }
    }
}
```

**è¯´æ˜**:
- `#[serde(default)]` è¡¨ç¤ºè¯¥å­—æ®µåœ¨ JSON ä¸­ä¸å­˜åœ¨æ—¶ä½¿ç”¨é»˜è®¤å€¼ `false`
- é»˜è®¤å…³é—­ä»¥ä¿æŒä¿å®ˆç­–ç•¥ï¼Œç”¨æˆ·éœ€æ‰‹åŠ¨å¯ç”¨

---

### 3.2 å¤‡é€‰æ¨¡å‹æ˜ å°„æ¨¡å—

**æ–‡ä»¶ä½ç½®**: `src-tauri/src/proxy/common/model_fallback.rs`

**æ“ä½œ**: æ–°å»ºæ–‡ä»¶

```rust
// æ¨¡å‹è½®è¯¢é™çº§æ˜ å°„æ¨¡å—
// å®šä¹‰å½“ä¸»æ¨¡å‹ä¸å¯ç”¨æ—¶çš„å¤‡é€‰æ¨¡å‹åˆ—è¡¨

/// æ¨¡å‹å®¶æ—åˆ†ç±»
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ModelFamily {
    /// Claude ç³»åˆ— (Opus, Sonnet, Haiku)
    Claude,
    /// GPT ç³»åˆ— (GPT-4, GPT-5)
    Gpt,
    /// Gemini ç³»åˆ— (Pro, Flash)
    Gemini,
    /// æ™ºè°±ç³»åˆ— (GLM)
    Zhipu,
    /// å…¶ä»–/æœªçŸ¥
    Unknown,
}

/// æ ¹æ®æ¨¡å‹ ID åˆ¤æ–­å…¶æ‰€å±å®¶æ—
pub fn get_model_family(model: &str) -> ModelFamily {
    let model_lower = model.to_lowercase();
    
    if model_lower.contains("claude") || model_lower.contains("opus") || model_lower.contains("sonnet") || model_lower.contains("haiku") {
        ModelFamily::Claude
    } else if model_lower.contains("gpt") || model_lower.contains("o1") || model_lower.contains("o3") || model_lower.contains("o4") {
        ModelFamily::Gpt
    } else if model_lower.contains("gemini") || model_lower.starts_with("models/") {
        ModelFamily::Gemini
    } else if model_lower.contains("glm") || model_lower.contains("zhipu") {
        ModelFamily::Zhipu
    } else {
        ModelFamily::Unknown
    }
}

/// è·å–æ¨¡å‹çš„å¤‡é€‰åˆ—è¡¨
/// 
/// è§„åˆ™ï¼š
/// - Claude/GPT æ¨¡å‹ -> [Gemini 3 Pro, Gemini 3 Flash]
/// - Gemini Pro æ¨¡å‹ -> [Claude Sonnet 4, Gemini 3 Flash]
/// - Gemini Flash æ¨¡å‹ -> [Claude Sonnet 4, Gemini 3 Pro]
/// - æ™ºè°±æ¨¡å‹ä½œä¸ºæœ€åå…œåº•ï¼ˆä»…å½“æ‰€æœ‰æ¨¡å‹ä¸å¯ç”¨æ—¶æ·»åŠ ï¼‰
/// 
/// è¿”å›çš„æ¨¡å‹ ID ä½¿ç”¨ Gemini çš„å®é™…æ¨¡å‹åæ ¼å¼
pub fn get_fallback_models(primary_model: &str) -> Vec<&'static str> {
    let family = get_model_family(primary_model);
    let model_lower = primary_model.to_lowercase();
    
    match family {
        ModelFamily::Claude | ModelFamily::Gpt => {
            // Claude/GPT -> ä¼˜å…ˆä½¿ç”¨ Gemini Proï¼Œç„¶å Flash
            vec![
                "gemini-2.5-pro",
                "gemini-2.5-flash",
            ]
        }
        ModelFamily::Gemini => {
            if model_lower.contains("flash") {
                // Gemini Flash -> ä¼˜å…ˆä½¿ç”¨ Claudeï¼Œç„¶å Gemini Pro
                vec![
                    "claude-sonnet-4-20250514",
                    "gemini-2.5-pro",
                ]
            } else {
                // Gemini Pro/å…¶ä»– -> ä¼˜å…ˆä½¿ç”¨ Claudeï¼Œç„¶å Flash
                vec![
                    "claude-sonnet-4-20250514",
                    "gemini-2.5-flash",
                ]
            }
        }
        ModelFamily::Zhipu => {
            // æ™ºè°±æ¨¡å‹ -> ä¼˜å…ˆä½¿ç”¨ Geminiï¼Œç„¶å Claude
            vec![
                "gemini-2.5-pro",
                "gemini-2.5-flash",
                "claude-sonnet-4-20250514",
            ]
        }
        ModelFamily::Unknown => {
            // æœªçŸ¥æ¨¡å‹ -> é»˜è®¤ä½¿ç”¨ Gemini
            vec![
                "gemini-2.5-pro",
                "gemini-2.5-flash",
            ]
        }
    }
}

/// è·å–æ™ºè°±å…œåº•æ¨¡å‹åˆ—è¡¨
/// ä»…å½“æ‰€æœ‰å…¶ä»–æ¨¡å‹éƒ½ä¸å¯ç”¨æ—¶ä½¿ç”¨
pub fn get_zhipu_fallback_models() -> Vec<&'static str> {
    vec![
        "glm-4-plus",
        "glm-4-flash",
    ]
}

/// åˆ¤æ–­æ¨¡å‹æ˜¯å¦ä¸ºé«˜å®¹é‡æ¨¡å‹ï¼ˆé€‚åˆç”¨äºé™çº§ï¼‰
pub fn is_high_capacity_model(model: &str) -> bool {
    let model_lower = model.to_lowercase();
    
    // Gemini æ¨¡å‹é€šå¸¸æœ‰æ›´é«˜çš„é…é¢
    model_lower.contains("gemini") ||
    model_lower.contains("flash") ||
    model_lower.contains("glm")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_model_family() {
        assert_eq!(get_model_family("claude-opus-4-5-thinking"), ModelFamily::Claude);
        assert_eq!(get_model_family("claude-sonnet-4-20250514"), ModelFamily::Claude);
        assert_eq!(get_model_family("gpt-5"), ModelFamily::Gpt);
        assert_eq!(get_model_family("gemini-2.5-pro"), ModelFamily::Gemini);
        assert_eq!(get_model_family("glm-4-plus"), ModelFamily::Zhipu);
    }

    #[test]
    fn test_get_fallback_models_for_claude() {
        let fallbacks = get_fallback_models("claude-opus-4-5-thinking");
        assert!(!fallbacks.is_empty());
        assert!(fallbacks[0].contains("gemini"));
    }

    #[test]
    fn test_get_fallback_models_for_gemini() {
        let fallbacks = get_fallback_models("gemini-2.5-pro");
        assert!(!fallbacks.is_empty());
        assert!(fallbacks[0].contains("claude"));
    }
}
```

**è¯´æ˜**:
- `get_model_family()` æ ¹æ®æ¨¡å‹åç§°è¯†åˆ«å…¶æ‰€å±å®¶æ—
- `get_fallback_models()` è¿”å›æŒ‰ä¼˜å…ˆçº§æ’åºçš„å¤‡é€‰æ¨¡å‹åˆ—è¡¨
- `get_zhipu_fallback_models()` æä¾›æ™ºè°±æ¨¡å‹ä½œä¸ºæœ€åå…œåº•
- å•å…ƒæµ‹è¯•ç¡®ä¿åŸºæœ¬é€»è¾‘æ­£ç¡®

---

### 3.3 å¯¼å‡ºæ¨¡å—

**æ–‡ä»¶ä½ç½®**: `src-tauri/src/proxy/common/mod.rs`

**ä¿®æ”¹å†…å®¹**: æ·»åŠ æ¨¡å—å¯¼å‡º

```rust
// Common æ¨¡å— - å…¬å…±å·¥å…·

// pub mod error;
// pub mod rate_limiter;
pub mod model_mapping;
pub mod model_fallback;  // æ–°å¢
pub mod utils;
pub mod json_schema;
```

---

### 3.4 ç†”æ–­å™¨å®ç°

**æ–‡ä»¶ä½ç½®**: `src-tauri/src/proxy/token_manager.rs`

**ä¿®æ”¹å†…å®¹ 1**: åœ¨ `TokenManager` ç»“æ„ä½“ä¸­æ·»åŠ ç†”æ–­å™¨å­˜å‚¨

```rust
pub struct TokenManager {
    tokens: Arc<DashMap<String, ProxyToken>>,
    current_index: Arc<AtomicUsize>,
    last_used_account: Arc<tokio::sync::Mutex<Option<(String, std::time::Instant)>>>,
    data_dir: PathBuf,
    rate_limit_tracker: Arc<RateLimitTracker>,
    sticky_config: Arc<tokio::sync::RwLock<StickySessionConfig>>,
    session_accounts: Arc<DashMap<String, String>>,
    
    /// æ¨¡å‹ç†”æ–­å™¨ï¼šmodel_id -> ç†”æ–­åˆ°æœŸæ—¶é—´
    /// å½“æŸæ¨¡å‹çš„æ‰€æœ‰è´¦å·éƒ½ä¸å¯ç”¨æ—¶ï¼Œè§¦å‘ç†”æ–­ï¼Œ5åˆ†é’Ÿå†…ä¸å†å°è¯•è¯¥æ¨¡å‹
    model_circuit_breaker: Arc<DashMap<String, std::time::Instant>>,
}
```

**ä¿®æ”¹å†…å®¹ 2**: åœ¨ `new()` æ–¹æ³•ä¸­åˆå§‹åŒ–ç†”æ–­å™¨

```rust
impl TokenManager {
    pub fn new(data_dir: PathBuf) -> Self {
        Self {
            tokens: Arc::new(DashMap::new()),
            current_index: Arc::new(AtomicUsize::new(0)),
            last_used_account: Arc::new(tokio::sync::Mutex::new(None)),
            data_dir,
            rate_limit_tracker: Arc::new(RateLimitTracker::new()),
            sticky_config: Arc::new(tokio::sync::RwLock::new(StickySessionConfig::default())),
            session_accounts: Arc::new(DashMap::new()),
            model_circuit_breaker: Arc::new(DashMap::new()),  // åˆå§‹åŒ–ç†”æ–­å™¨
        }
    }
    
    // ... å…¶ä»–æ–¹æ³•
}
```

**ä¿®æ”¹å†…å®¹ 3**: æ·»åŠ ç†”æ–­å™¨æ“ä½œæ–¹æ³•ï¼ˆåœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ï¼‰

```rust
impl TokenManager {
    // ... å…¶ä»–æ–¹æ³•

    // ===== æ¨¡å‹ç†”æ–­å™¨æ–¹æ³• (Model Circuit Breaker) =====

    /// æ£€æŸ¥æ¨¡å‹æ˜¯å¦å¤„äºç†”æ–­çŠ¶æ€
    /// å¦‚æœç†”æ–­å·²è¿‡æœŸï¼Œè‡ªåŠ¨æ¸…é™¤å¹¶è¿”å› false
    pub fn is_model_circuit_broken(&self, model: &str) -> bool {
        let normalized = crate::proxy::common::model_mapping::normalize_to_standard_id(model)
            .unwrap_or_else(|| model.to_string());
        
        if let Some(expires_at) = self.model_circuit_breaker.get(&normalized) {
            if std::time::Instant::now() < *expires_at {
                tracing::debug!("âš¡ Model {} is circuit-broken, will retry in {:?}", 
                    normalized, expires_at.duration_since(std::time::Instant::now()));
                return true;
            } else {
                // ç†”æ–­å·²è¿‡æœŸï¼Œæ¸…é™¤
                drop(expires_at);
                self.model_circuit_breaker.remove(&normalized);
                tracing::info!("âœ… Model {} circuit breaker expired, retrying", normalized);
            }
        }
        false
    }

    /// è§¦å‘æ¨¡å‹ç†”æ–­
    /// duration_secs: ç†”æ–­æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 300 ç§’ (5 åˆ†é’Ÿ)
    pub fn trip_model_circuit_breaker(&self, model: &str, duration_secs: u64) {
        let normalized = crate::proxy::common::model_mapping::normalize_to_standard_id(model)
            .unwrap_or_else(|| model.to_string());
        
        let expires_at = std::time::Instant::now() + std::time::Duration::from_secs(duration_secs);
        self.model_circuit_breaker.insert(normalized.clone(), expires_at);
        
        tracing::warn!(
            "âš¡ Model {} circuit breaker TRIPPED! Will not retry for {} seconds",
            normalized, duration_secs
        );
    }

    /// æ‰‹åŠ¨é‡ç½®æ¨¡å‹ç†”æ–­çŠ¶æ€
    #[allow(dead_code)]
    pub fn reset_model_circuit_breaker(&self, model: &str) {
        let normalized = crate::proxy::common::model_mapping::normalize_to_standard_id(model)
            .unwrap_or_else(|| model.to_string());
        
        if self.model_circuit_breaker.remove(&normalized).is_some() {
            tracing::info!("âœ… Model {} circuit breaker manually reset", normalized);
        }
    }

    /// æ¸…é™¤æ‰€æœ‰æ¨¡å‹ç†”æ–­çŠ¶æ€
    #[allow(dead_code)]
    pub fn clear_all_circuit_breakers(&self) {
        let count = self.model_circuit_breaker.len();
        self.model_circuit_breaker.clear();
        if count > 0 {
            tracing::info!("âœ… Cleared {} model circuit breaker(s)", count);
        }
    }

    /// è·å–æ‰€æœ‰å½“å‰ç†”æ–­çš„æ¨¡å‹åˆ—è¡¨
    #[allow(dead_code)]
    pub fn get_circuit_broken_models(&self) -> Vec<String> {
        let now = std::time::Instant::now();
        self.model_circuit_breaker
            .iter()
            .filter(|entry| *entry.value() > now)
            .map(|entry| entry.key().clone())
            .collect()
    }
}
```

**è¯´æ˜**:
- ä½¿ç”¨ `DashMap` å®ç°çº¿ç¨‹å®‰å…¨çš„ç†”æ–­å™¨å­˜å‚¨
- `normalize_to_standard_id` ç¡®ä¿æ¨¡å‹åç§°ä¸€è‡´æ€§
- ç†”æ–­æ—¶é—´ä½¿ç”¨ `std::time::Instant` é¿å…ç³»ç»Ÿæ—¶é’Ÿé—®é¢˜
- æä¾›å®Œæ•´çš„ CRUD æ“ä½œæ–¹æ³•

---

### 3.5 è½®è¯¢é€»è¾‘é›†æˆ

**æ–‡ä»¶ä½ç½®**: `src-tauri/src/proxy/handlers/claude.rs`

**ä¿®æ”¹ä½ç½®**: `handle_messages` å‡½æ•°ä¸­ï¼Œåœ¨ `token_manager.get_token()` å¤±è´¥çš„ `Err(e)` åˆ†æ”¯å†…

**å®Œæ•´ä»£ç **:

```rust
let (access_token, project_id, email) = match token_manager.get_token(&config.request_type, force_rotate_token, session_id, &config.final_model).await {
    Ok(t) => t,
    Err(e) => {
        // ===== [æ¨¡å‹è½®è¯¢] å½“ä¸»æ¨¡å‹è´¦å·å…¨éƒ¨ä¸å¯ç”¨æ—¶ï¼Œå°è¯•å¤‡é€‰æ¨¡å‹ =====
        let polling_enabled = state.experimental.read().await.enable_model_polling;
        
        if polling_enabled {
            // è§¦å‘ä¸»æ¨¡å‹ç†”æ–­ï¼ˆ5åˆ†é’Ÿï¼‰
            token_manager.trip_model_circuit_breaker(&request_for_body.model, 300);
            
            // è·å–å¤‡é€‰æ¨¡å‹åˆ—è¡¨
            let fallback_models = crate::proxy::common::model_fallback::get_fallback_models(&request_for_body.model);
            
            tracing::info!(
                "[{}] ğŸ”„ ä¸»æ¨¡å‹ {} ä¸å¯ç”¨ï¼Œå¯åŠ¨æ¨¡å‹è½®è¯¢ï¼Œå°è¯•å¤‡é€‰æ¨¡å‹: {:?}",
                trace_id, request_for_body.model, fallback_models
            );
            
            // å°è¯•æ¯ä¸ªå¤‡é€‰æ¨¡å‹
            for fallback_model in fallback_models {
                // æ£€æŸ¥å¤‡é€‰æ¨¡å‹æ˜¯å¦ä¹Ÿè¢«ç†”æ–­
                if token_manager.is_model_circuit_broken(fallback_model) {
                    tracing::debug!("[{}] å¤‡é€‰æ¨¡å‹ {} ä¹Ÿå¤„äºç†”æ–­çŠ¶æ€ï¼Œè·³è¿‡", trace_id, fallback_model);
                    continue;
                }
                
                // åˆ›å»ºä¸€ä¸ªä½¿ç”¨å¤‡é€‰æ¨¡å‹çš„è¯·æ±‚å‰¯æœ¬
                let mut fallback_request = request_for_body.clone();
                fallback_request.model = fallback_model.to_string();
                
                // å¤‡é€‰æ¨¡å‹å¯èƒ½ä¸æ”¯æŒ Thinkingï¼Œéœ€è¦æ¸…ç†
                if fallback_model.contains("flash") || fallback_model.contains("gemini") {
                    fallback_request.thinking = None;
                    // æ¸…ç†å†å² Thinking å—
                    for msg in fallback_request.messages.iter_mut() {
                        if let crate::proxy::mappers::claude::models::MessageContent::Array(blocks) = &mut msg.content {
                            blocks.retain(|b| !matches!(b, 
                                crate::proxy::mappers::claude::models::ContentBlock::Thinking { .. } |
                                crate::proxy::mappers::claude::models::ContentBlock::RedactedThinking { .. }
                            ));
                        }
                    }
                }
                
                // é‡æ–°è·å–é…ç½®å’Œå°è¯•è·å– token
                let fallback_config = crate::proxy::mappers::common_utils::resolve_request_config(
                    &fallback_request.model, 
                    &fallback_request.model, 
                    &None
                );
                
                match token_manager.get_token(&fallback_config.request_type, false, session_id, &fallback_config.final_model).await {
                    Ok((fb_token, fb_project, fb_email)) => {
                        tracing::info!(
                            "[{}] âœ… è½®è¯¢æˆåŠŸï¼ä½¿ç”¨å¤‡é€‰æ¨¡å‹: {} (è´¦å·: {})",
                            trace_id, fallback_model, fb_email
                        );
                        
                        // æ›´æ–° request_for_body ä¸ºå¤‡é€‰æ¨¡å‹
                        request_for_body = fallback_request;
                        
                        // ç›´æ¥å¤„ç†å¤‡é€‰æ¨¡å‹è¯·æ±‚
                        let mapped_model = fallback_model.to_string();
                        let gemini_body = match transform_claude_request_in(&request_for_body, &fb_project, false) {
                            Ok(b) => b,
                            Err(transform_err) => {
                                tracing::error!("[{}] å¤‡é€‰æ¨¡å‹è½¬æ¢å¤±è´¥: {}", trace_id, transform_err);
                                continue;
                            }
                        };
                        
                        let client_wants_stream = request.stream;
                        let actual_stream = true; // å¤‡é€‰æ¨¡å‹å§‹ç»ˆä½¿ç”¨ stream
                        let method = "streamGenerateContent";
                        let query = Some("alt=sse");
                        
                        let extra_headers = std::collections::HashMap::new();
                        
                        // è°ƒç”¨ä¸Šæ¸¸
                        match upstream.call_v1_internal_with_headers(method, &fb_token, gemini_body, query, extra_headers).await {
                            Ok(response) => {
                                if response.status().is_success() {
                                    token_manager.mark_account_success(&fb_email);
                                    
                                    let context_limit = crate::proxy::mappers::claude::utils::get_context_limit_for_model(&mapped_model);
                                    let stream = response.bytes_stream();
                                    let gemini_stream = Box::pin(stream);
                                    let mut claude_stream = create_claude_sse_stream(
                                        gemini_stream, 
                                        trace_id.clone(), 
                                        fb_email.clone(),
                                        Some(session_id_str.clone()),
                                        scaling_enabled,
                                        context_limit
                                    );
                                    
                                    let first_chunk = claude_stream.next().await;
                                    
                                    match first_chunk {
                                        Some(Ok(bytes)) if !bytes.is_empty() => {
                                            let stream_rest = claude_stream;
                                            let combined_stream = Box::pin(
                                                futures::stream::once(async move { Ok(bytes) })
                                                    .chain(stream_rest.map(|result| -> Result<Bytes, std::io::Error> {
                                                        match result {
                                                            Ok(b) => Ok(b),
                                                            Err(e) => Ok(Bytes::from(format!("data: {{\"error\":\"{}\"}}\n\n", e))),
                                                        }
                                                    }))
                                            );
                                            
                                            if client_wants_stream {
                                                return Response::builder()
                                                    .status(StatusCode::OK)
                                                    .header(header::CONTENT_TYPE, "text/event-stream")
                                                    .header(header::CACHE_CONTROL, "no-cache")
                                                    .header(header::CONNECTION, "keep-alive")
                                                    .header("X-Account-Email", &fb_email)
                                                    .header("X-Mapped-Model", &mapped_model)
                                                    .header("X-Fallback-Model", "true")  // æ ‡è¯†ä½¿ç”¨äº†å¤‡é€‰æ¨¡å‹
                                                    .body(Body::from_stream(combined_stream))
                                                    .unwrap();
                                            } else {
                                                use crate::proxy::mappers::claude::collect_stream_to_json;
                                                match collect_stream_to_json(combined_stream).await {
                                                    Ok(full_response) => {
                                                        return Response::builder()
                                                            .status(StatusCode::OK)
                                                            .header(header::CONTENT_TYPE, "application/json")
                                                            .header("X-Account-Email", &fb_email)
                                                            .header("X-Mapped-Model", &mapped_model)
                                                            .header("X-Fallback-Model", "true")
                                                            .body(Body::from(serde_json::to_string(&full_response).unwrap()))
                                                            .unwrap();
                                                    }
                                                    Err(collect_err) => {
                                                        tracing::warn!("[{}] å¤‡é€‰æ¨¡å‹å“åº”æ”¶é›†å¤±è´¥: {}", trace_id, collect_err);
                                                        continue;
                                                    }
                                                }
                                            }
                                        }
                                        _ => {
                                            tracing::warn!("[{}] å¤‡é€‰æ¨¡å‹ {} è¿”å›ç©ºå“åº”", trace_id, fallback_model);
                                            continue;
                                        }
                                    }
                                } else {
                                    let status_code = response.status().as_u16();
                                    tracing::warn!("[{}] å¤‡é€‰æ¨¡å‹ {} è¯·æ±‚å¤±è´¥: HTTP {}", trace_id, fallback_model, status_code);
                                    if status_code == 429 || status_code == 503 {
                                        token_manager.trip_model_circuit_breaker(fallback_model, 300);
                                    }
                                    continue;
                                }
                            }
                            Err(upstream_err) => {
                                tracing::warn!("[{}] å¤‡é€‰æ¨¡å‹ {} ä¸Šæ¸¸è°ƒç”¨å¤±è´¥: {}", trace_id, fallback_model, upstream_err);
                                continue;
                            }
                        }
                    }
                    Err(_) => {
                        tracing::debug!("[{}] å¤‡é€‰æ¨¡å‹ {} ä¹Ÿæ— å¯ç”¨è´¦å·ï¼Œç»§ç»­å°è¯•", trace_id, fallback_model);
                        token_manager.trip_model_circuit_breaker(fallback_model, 300);
                        continue;
                    }
                }
            }
            
            // å¦‚æœæ‰€æœ‰å¤‡é€‰æ¨¡å‹éƒ½å¤±è´¥ï¼Œå°è¯•æ™ºè°±å…œåº•
            let zhipu_models = crate::proxy::common::model_fallback::get_zhipu_fallback_models();
            tracing::info!("[{}] æ‰€æœ‰å¤‡é€‰æ¨¡å‹ä¸å¯ç”¨ï¼Œå°è¯•æ™ºè°±å…œåº•: {:?}", trace_id, zhipu_models);
            
            // æ™ºè°±æ¨¡å‹éœ€è¦ä½¿ç”¨ z.ai è·¯ç”±ï¼Œè¿™é‡Œåªè®°å½•æ—¥å¿—
            // å®é™…æ™ºè°±è°ƒç”¨éœ€è¦é€šè¿‡ zai é…ç½®
        }
        
        // åŸæœ‰é”™è¯¯å¤„ç†é€»è¾‘
        let safe_message = if e.contains("invalid_grant") {
            "OAuth refresh failed (invalid_grant): refresh_token likely revoked/expired; reauthorize account(s) to restore service.".to_string()
        } else {
            e
        };
        return (
            StatusCode::SERVICE_UNAVAILABLE,
            Json(json!({
                "type": "error",
                "error": {
                    "type": "overloaded_error",
                    "message": format!("No available accounts: {}", safe_message)
                }
            }))
        ).into_response();
    }
};
```

**è¯´æ˜**:
- é¦–å…ˆæ£€æŸ¥ `enable_model_polling` é…ç½®æ˜¯å¦å¯ç”¨
- è§¦å‘ä¸»æ¨¡å‹ 5 åˆ†é’Ÿç†”æ–­
- éå†å¤‡é€‰æ¨¡å‹åˆ—è¡¨ï¼Œè·³è¿‡å·²ç†”æ–­çš„æ¨¡å‹
- å¯¹äº Gemini/Flash æ¨¡å‹ï¼Œæ¸…ç†ä¸æ”¯æŒçš„ Thinking é…ç½®
- æˆåŠŸæ—¶æ·»åŠ  `X-Fallback-Model: true` å“åº”å¤´
- å¤±è´¥æ—¶æ ¹æ®é”™è¯¯ç±»å‹è§¦å‘å¤‡é€‰æ¨¡å‹ç†”æ–­
- æœ€åå°è¯•æ™ºè°±æ¨¡å‹å…œåº•ï¼ˆéœ€è¦ z.ai é…ç½®ï¼‰

---

### 3.6 å‰ç«¯ç±»å‹å®šä¹‰

**æ–‡ä»¶ä½ç½®**: `src/types/config.ts`

**ä¿®æ”¹å†…å®¹**:

```typescript
export interface ExperimentalConfig {
    enable_usage_scaling: boolean;
    enable_model_polling?: boolean;  // æ–°å¢
}
```

---

### 3.7 å‰ç«¯ UI å¼€å…³

**æ–‡ä»¶ä½ç½®**: `src/pages/ApiProxy.tsx`

**ä¿®æ”¹ä½ç½®**: å®éªŒæ€§è®¾ç½®å¡ç‰‡ (`CollapsibleCard`) å†…éƒ¨

**æ·»åŠ ä»£ç **:

```tsx
{/* æ™ºèƒ½æ¨¡å‹è½®è¯¢ */}
<div className="flex items-center justify-between p-4 bg-gray-50 dark:bg-base-200 rounded-xl border border-gray-100 dark:border-base-300">
    <div className="space-y-1">
        <div className="flex items-center gap-2">
            <span className="text-sm font-bold text-gray-900 dark:text-base-content">
                {t('proxy.config.experimental.enable_model_polling')}
            </span>
            <HelpTooltip text={t('proxy.config.experimental.enable_model_polling_tooltip')} />
            <span className="px-1.5 py-0.5 rounded bg-green-100 dark:bg-green-900/30 text-[10px] text-green-600 dark:text-green-400 font-bold border border-green-200 dark:border-green-800">
                Gemini
            </span>
        </div>
        <p className="text-[10px] text-gray-500 dark:text-gray-400 max-w-lg">
            {t('proxy.config.experimental.enable_model_polling_tooltip')}
        </p>
    </div>
    <label className="relative inline-flex items-center cursor-pointer">
        <input
            type="checkbox"
            className="sr-only peer"
            checked={!!appConfig.proxy.experimental?.enable_model_polling}
            onChange={(e) => updateExperimentalConfig({ enable_model_polling: e.target.checked })}
        />
        <div className="w-11 h-6 bg-gray-200 dark:bg-base-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500 shadow-inner"></div>
    </label>
</div>
```

---

### 3.8 ä¸­æ–‡ç¿»è¯‘

**æ–‡ä»¶ä½ç½®**: `src/locales/zh.json`

**ä¿®æ”¹ä½ç½®**: `proxy.config.experimental` å¯¹è±¡å†…

```json
"experimental": {
    "title": "å®éªŒæ€§è®¾ç½® (Experimental)",
    "title_tooltip": "æ¢ç´¢æ€§åŠŸèƒ½ï¼Œå¯èƒ½åœ¨æœªæ¥ç‰ˆæœ¬ä¸­è°ƒæ•´æˆ–ç§»é™¤ã€‚",
    "enable_usage_scaling": "å¯ç”¨ç”¨é‡ç¼©æ”¾",
    "enable_usage_scaling_tooltip": "é’ˆå¯¹ Claude å…¼å®¹åè®®ã€‚å½“æ€»è¾“å…¥è¶…è¿‡ 30k Token æ—¶å¼€å¯æ¿€è¿›ç¼©æ”¾ï¼Œé˜²æ­¢åœ¨å¤§ä¸Šä¸‹æ–‡ä¸‹é¢‘ç¹è§¦å‘å®¢æˆ·ç«¯å‹ç¼©ã€‚æ³¨æ„ï¼šå¼€å¯åå®¢æˆ·ç«¯æ˜¾ç¤ºçš„ç”¨é‡ä¸å†ä»£è¡¨å®é™…è®¡è´¹ç‚¹æ•°ã€‚",
    "enable_model_polling": "å¯ç”¨æ™ºèƒ½æ¨¡å‹è½®è¯¢",
    "enable_model_polling_tooltip": "å½“ä¸»æ¨¡å‹çš„æ‰€æœ‰è´¦å·ä¸å¯ç”¨ï¼ˆé¢åº¦è€—å°½æˆ–è¢«é™æµï¼‰æ—¶ï¼Œè‡ªåŠ¨å°è¯•å¤‡é€‰æ¨¡å‹ï¼ˆå¦‚ Gemini 2.5 Pro/Flashï¼‰ã€‚ä½¿ç”¨ 5 åˆ†é’Ÿç†”æ–­æœºåˆ¶é¿å…é‡å¤å°è¯•å¤±è´¥çš„æ¨¡å‹ï¼Œæ˜¾è‘—å‡å°‘é”™è¯¯æ—¥å¿—å’Œå“åº”å»¶è¿Ÿã€‚"
}
```

---

### 3.9 è‹±æ–‡ç¿»è¯‘

**æ–‡ä»¶ä½ç½®**: `src/locales/en.json`

**ä¿®æ”¹ä½ç½®**: `proxy.config.experimental` å¯¹è±¡å†…

```json
"experimental": {
    "title": "Experimental Settings",
    "title_tooltip": "Exploratory features that may be adjusted or removed in future versions.",
    "enable_usage_scaling": "Enable Usage Scaling",
    "enable_usage_scaling_tooltip": "For Claude protocol. Enables aggressive scaling when total input exceeds 30k tokens to prevent frequent client-side compression. Note: Reported usage will not reflect actual billing after enabling.",
    "enable_model_polling": "Enable Smart Model Polling",
    "enable_model_polling_tooltip": "When all accounts for the primary model are unavailable (quota exhausted or rate-limited), automatically try fallback models (e.g., Gemini 2.5 Pro/Flash). Uses a 5-minute circuit breaker to avoid repeated attempts on failed models, significantly reducing error logs and response latency."
}
```

---

## å››ã€å·¥ä½œæµç¨‹å›¾

```
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   å®¢æˆ·ç«¯è¯·æ±‚         â”‚
                      â”‚ model: claude-opus   â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚  get_token() è·å–è´¦å·â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚                         â”‚
              è·å–æˆåŠŸ                    è·å–å¤±è´¥
                   â”‚                         â”‚
                   â–¼                         â–¼
            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚ æ­£å¸¸å¤„ç†è¯·æ±‚  â”‚         â”‚ enable_model_polling?â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                               â”‚
                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                    â”‚                     â”‚
                                   å¯ç”¨                   ç¦ç”¨
                                    â”‚                     â”‚
                                    â–¼                     â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ è§¦å‘ä¸»æ¨¡å‹ç†”æ–­(5åˆ†é’Ÿ)â”‚     â”‚ è¿”å›åŸå§‹é”™è¯¯  â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ è·å–å¤‡é€‰æ¨¡å‹åˆ—è¡¨     â”‚
                      â”‚ [gemini-pro, flash] â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”Œâ”€â”€â”€â–¶â”‚  å–ä¸‹ä¸€ä¸ªå¤‡é€‰æ¨¡å‹    â”‚
                 â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚              â”‚
                 â”‚              â–¼
                 â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚    â”‚ æ£€æŸ¥æ˜¯å¦è¢«ç†”æ–­?      â”‚
                 â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚              â”‚
                 â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚    â”‚                   â”‚
                 â”‚   æ˜¯                   å¦
                 â”‚    â”‚                   â”‚
                 â”‚    â”‚                   â–¼
                 â”‚    â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚    â”‚         â”‚ get_token() è·å–è´¦å·â”‚
                 â”‚    â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚    â”‚                   â”‚
                 â”‚    â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚    â”‚         â”‚                   â”‚
                 â”‚    â”‚      è·å–å¤±è´¥            è·å–æˆåŠŸ
                 â”‚    â”‚         â”‚                   â”‚
                 â”‚    â”‚         â–¼                   â–¼
                 â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚    â”‚  â”‚ è§¦å‘è¯¥æ¨¡å‹ç†”æ–­â”‚  â”‚ è°ƒç”¨å¤‡é€‰æ¨¡å‹API   â”‚
                 â”‚    â””â”€â”€â”¤              â”‚  â”‚ X-Fallback: true â”‚
                 â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚                                 â”‚
                 â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚                        â”‚               â”‚
                 â”‚                      æˆåŠŸ            å¤±è´¥
                 â”‚                        â”‚               â”‚
                 â”‚                        â–¼               â”‚
                 â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
                 â”‚                 â”‚ è¿”å›æˆåŠŸå“åº”  â”‚       â”‚
                 â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
                 â”‚                                        â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## äº”ã€é…ç½®ç¤ºä¾‹

### 5.1 åç«¯é…ç½®æ–‡ä»¶æ ¼å¼

é…ç½®å­˜å‚¨åœ¨ `~/.antigravity/config.json`:

```json
{
  "proxy": {
    "experimental": {
      "enable_signature_cache": true,
      "enable_tool_loop_recovery": true,
      "enable_cross_model_checks": true,
      "enable_usage_scaling": true,
      "enable_model_polling": true
    }
  }
}
```

### 5.2 ç¯å¢ƒå˜é‡ï¼ˆå¯é€‰æ‰©å±•ï¼‰

æœªæ¥å¯æ”¯æŒç¯å¢ƒå˜é‡è¦†ç›–ï¼š

```bash
export ANTIGRAVITY_MODEL_POLLING=true
```

---

## å…­ã€æ—¥å¿—ç¤ºä¾‹

### 6.1 è½®è¯¢æˆåŠŸ

```log
INFO  [abc123] ğŸ”„ ä¸»æ¨¡å‹ claude-opus-4-5-thinking ä¸å¯ç”¨ï¼Œå¯åŠ¨æ¨¡å‹è½®è¯¢ï¼Œå°è¯•å¤‡é€‰æ¨¡å‹: ["gemini-2.5-pro", "gemini-2.5-flash"]
WARN  âš¡ Model claude-opus-4-5-thinking circuit breaker TRIPPED! Will not retry for 300 seconds
INFO  [abc123] âœ… è½®è¯¢æˆåŠŸï¼ä½¿ç”¨å¤‡é€‰æ¨¡å‹: gemini-2.5-pro (è´¦å·: user@example.com)
```

### 6.2 å…¨éƒ¨å¤±è´¥

```log
INFO  [def456] ğŸ”„ ä¸»æ¨¡å‹ claude-sonnet-4 ä¸å¯ç”¨ï¼Œå¯åŠ¨æ¨¡å‹è½®è¯¢
WARN  âš¡ Model claude-sonnet-4 circuit breaker TRIPPED! Will not retry for 300 seconds
DEBUG [def456] å¤‡é€‰æ¨¡å‹ gemini-2.5-pro ä¹Ÿå¤„äºç†”æ–­çŠ¶æ€ï¼Œè·³è¿‡
DEBUG [def456] å¤‡é€‰æ¨¡å‹ gemini-2.5-flash ä¹Ÿæ— å¯ç”¨è´¦å·ï¼Œç»§ç»­å°è¯•
WARN  âš¡ Model gemini-2.5-flash circuit breaker TRIPPED! Will not retry for 300 seconds
INFO  [def456] æ‰€æœ‰å¤‡é€‰æ¨¡å‹ä¸å¯ç”¨ï¼Œå°è¯•æ™ºè°±å…œåº•: ["glm-4-plus", "glm-4-flash"]
```

---

## ä¸ƒã€åç»­å‡çº§å»ºè®®

### 7.1 å¾…å®ç°åŠŸèƒ½

1. **æ™ºè°±æ¨¡å‹å®é™…è°ƒç”¨**: å½“å‰ä»…è®°å½•æ—¥å¿—ï¼Œéœ€é›†æˆ z.ai è·¯ç”±
2. **åŠ¨æ€ç†”æ–­æ—¶é—´**: æ ¹æ®å¤±è´¥ç±»å‹è°ƒæ•´ç†”æ–­æ—¶é—´
3. **ç†”æ–­çŠ¶æ€ API**: æä¾› HTTP API æŸ¥è¯¢/æ¸…é™¤ç†”æ–­çŠ¶æ€
4. **UI çŠ¶æ€æ˜¾ç¤º**: åœ¨ç•Œé¢æ˜¾ç¤ºå½“å‰ç†”æ–­çš„æ¨¡å‹åˆ—è¡¨

### 7.2 æ‰©å±•å¤‡é€‰æ¨¡å‹

ä¿®æ”¹ `model_fallback.rs` çš„ `get_fallback_models()` å‡½æ•°ï¼š

```rust
// æ·»åŠ æ–°çš„å¤‡é€‰æ¨¡å‹
vec![
    "gemini-2.5-pro",
    "gemini-2.5-flash",
    "gemini-3-pro",       // æ–°å¢
    "deepseek-v3",        // æ–°å¢
]
```

### 7.3 è°ƒæ•´ç†”æ–­æ—¶é—´

åœ¨ `claude.rs` ä¸­ä¿®æ”¹ç†”æ–­è°ƒç”¨ï¼š

```rust
// å°† 300 ç§’æ”¹ä¸ºå…¶ä»–å€¼
token_manager.trip_model_circuit_breaker(&request_for_body.model, 600);  // 10åˆ†é’Ÿ
```

---

## å…«ã€æµ‹è¯•éªŒè¯

### 8.1 å•å…ƒæµ‹è¯•

```bash
cd src-tauri
cargo test model_fallback
```

### 8.2 ç¼–è¯‘éªŒè¯

```bash
cd src-tauri
cargo check
```

### 8.3 å‰ç«¯æ„å»º

```bash
npm run build
```

---

å®Œæˆæ—¥æœŸ: 2026-01-19
